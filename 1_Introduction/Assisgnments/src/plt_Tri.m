% 本函数输入为变换次数n（初始图像序号为0）,返回经过n次变换后的图像，并且排布在m子图中
% 算法：使用复数可以表示平面上的一个点（向量），而使用复数序列则可以直接确定平面上的一个图形
% 让z_n序列表示第n次变换的图形，n=1 时，序列z_1=[z11 z12 z13 z11]=[0 1 (sqrt(3)i+1)/2 0]
% 算法关键在于如何找到前一次序列到下一次序列的映射T
% T: 找三等分点，关键计算每一个矢量的差（方向+大小） Δz=z11-z12，中间插入三等分点 
% x1=z1+Δz/3,x2=x1+Δz*e^i(-pi/3)/3,x3=x2+Δz/3
% 复数的好处就在于旋转可以用乘以一个指数来表示
function plt_Tri(n,m)
z=[1 (1+sqrt(3)*i)/2 0 1]; % 初始序列,表示原始图形的四个顶点（初始点重复计算）
iter=n;
for j=1:iter              % 上述映射变换的迭代次数
    z_0=z;                % 给定初始序列（图形），后面根据循环更新插入新点
    div=length(z)-1;      % 计算（插入三等分掉操作）次数，也即边的条数例如第一次有4点三条边，第二次有13个点12条边
    %需要对每一条边这样处理，用循环
    for k=1:div
        dz=(z_0(k+1)-z_0(k))/3; %计算原图形相邻两点差（即要插的边）
        %开始生成第一条边对应的图形，每一个图形都是4点一个单位
        z(4*k-3)=z_0(k);        %起点
        z(4*k-2)=z_0(k)+dz;     %第一个三等分点 
        z(4*k-1)=z(4*k-2)+dz*(1/2-sqrt(3)*1i/2); %第二个点，需要旋转出去的
        z(4*k)=z_0(k)+2*dz;   %第二个三等分点
    end
    z(4*div+1)=z_0(div+1);        %终点
    subplot(m,ceil(n/m),j)
    fill(real(z),imag(z),'k')
    title(['stage',num2str(j)])
    axis equal
end
end

