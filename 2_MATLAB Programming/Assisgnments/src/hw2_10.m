clear all
clc

% 广度优先的思想可以用于求解最短路径，在选择时将所有分支放入备选项，并且，每一分支后续路线不能再经过先前的备选项，否则，前一次选择时可以直接到那一重复的备选项
% 也即一层中先遍历所有分支（广度优先）

% 用矩阵表示迷宫，1表示可通行，0表示墙壁
Maze=[1 1 0 0 0 1 0 0 0 0;
      0 1 0 0 0 1 1 1 1 1;
      0 1 0 0 0 1 0 0 1 0;
      0 1 1 1 1 1 0 0 1 0;
      0 1 0 1 1 0 0 0 1 0;
      0 1 0 0 1 0 0 0 1 0;
      0 1 0 0 1 0 0 0 1 0;
      1 1 0 0 1 1 0 0 1 0;
      0 0 0 0 0 1 1 1 1 1;
      0 0 0 0 0 0 0 0 0 1];
Solution=Maze;                  % 定义结果展示矩阵，便与绘图展示保存迷宫初始样式（因为迷宫在BFS过程中会标记走过发生改动）

P=[1 1 -1];           % 起点为(1,1),第三个量为该路径中上一个点在队列中的下标，先默认-1，用于反向求路径
q_p={P};              % 存放迷宫坐标点的队列
Maze(P(1),P(2))=0;    % 用0表示迷宫中的某一个点已经走过,不能再走，因为是BFS要求不能再经过前一分支的备选项
flag=false;           % 判断是否能够走到终点，预设为不能
dx=[1 -1 0 0];        % 1表示向右，-1表示向左
dy=[0 0 1 -1];        % 1表示向上，-1表示向下

 
% 初始点进队，队列不为空时循环
% 循环体内：
% 出队一个点p，标记为已走过，找p四周所有可以走的方向，假设有p1，p2，将其入队
% 重复上面操作，直到p的坐标与出口坐标相等，找到了出口，同时逆向查找至入口，得出最短路径

front=1;
rear=2;
while(front<rear)                   % 队列为空则证明找不到出口
       for i=1:4                    % 未找到终点前，得一直向四周进行搜索，能走就进队
           P_try=[q_p{front}(1)+dy(i),q_p{front}(2)+dx(i)];
           if(P_try(1)<1|P_try(1)>10|P_try(2)<1|P_try(2)>10)
               continue
           end
           if( Maze(P_try(1),P_try(2))==1) % 若可访问
               temp=[P_try(1) P_try(2) front];
               q_p{end+1}=temp;
               rear=rear+1;
               Maze(P_try(1),P_try(2))=0;      % 把访问过的地方标记成不能走
           end
           if(P_try(1)==10&P_try(2)==10)
               flag=true;                       % 找到解的判断符取真
               pre=front;                       % 当前点，准备回溯路径
               Solution(P_try(1),P_try(2))=0.5; % 回溯路径，从倒数第二格开始，因此最后一格先标记
               dis=0;                           % 回溯路径，从倒数第二开始
               while(pre~=-1)                   % 回溯路径，并且把对应点标为0.5，方便用图像展示
                   Solution(q_p{pre}(1),q_p{pre}(2))=0.5;
                   pre=q_p{pre}(3);
                   dis=dis+1;                  % 路径统计长度
               end
           end
       end
        front=front+1;
end
if(~flag)
    disp('找不到走出迷宫的路！')
else
    disp(['最短路径长度为',num2str(dis)])
    image(Solution,'CDataMapping','scaled');
    title('广度优先搜索最短路径展示')
end


            
                
            
        
    
    